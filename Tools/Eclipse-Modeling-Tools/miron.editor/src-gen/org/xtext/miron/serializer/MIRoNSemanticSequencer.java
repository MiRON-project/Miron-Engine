/*
 * generated by Xtext 2.12.0
 */
package org.xtext.miron.serializer;

import com.google.inject.Inject;
import java.util.Set;
import miron.metamodel.datatypes.BehaviorTreeEnumType;
import miron.metamodel.datatypes.BehaviorTreeLiteral;
import miron.metamodel.datatypes.ImpactOnQuality;
import miron.metamodel.datatypes.MironModel;
import miron.metamodel.datatypes.NumericSampledType;
import miron.metamodel.datatypes.SampleValue;
import miron.metamodel.kernel.ArchBinding;
import miron.metamodel.kernel.BtBinding;
import miron.metamodel.kernel.Condition;
import miron.metamodel.kernel.Constraint;
import miron.metamodel.kernel.Import;
import miron.metamodel.kernel.KernelPackage;
import miron.metamodel.kernel.Rule;
import miron.metamodel.kernel.VariationPoint;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.miron.services.MIRoNGrammarAccess;
import org.xtext.roqme.serializer.RoQMESemanticSequencer;
import roqme.metamodel.datatypes.ArrayValue;
import roqme.metamodel.datatypes.BooleanType;
import roqme.metamodel.datatypes.BooleanValue;
import roqme.metamodel.datatypes.ContainedDeclaration;
import roqme.metamodel.datatypes.DataTypeDefinition;
import roqme.metamodel.datatypes.DatatypesPackage;
import roqme.metamodel.datatypes.EnumValue;
import roqme.metamodel.datatypes.EventType;
import roqme.metamodel.datatypes.EventValue;
import roqme.metamodel.datatypes.InbuiltDeclaration;
import roqme.metamodel.datatypes.LowerBound;
import roqme.metamodel.datatypes.NumericType;
import roqme.metamodel.datatypes.NumericValue;
import roqme.metamodel.datatypes.Precision;
import roqme.metamodel.datatypes.ReferencedDeclaration;
import roqme.metamodel.datatypes.RoqmeModel;
import roqme.metamodel.datatypes.SimpleEnumLiteral;
import roqme.metamodel.datatypes.SimpleEnumType;
import roqme.metamodel.datatypes.TimeType;
import roqme.metamodel.datatypes.TimeValue;
import roqme.metamodel.datatypes.UpperBound;
import roqme.metamodel.expressions.AddTerm;
import roqme.metamodel.expressions.AggregationFunction;
import roqme.metamodel.expressions.AndBooleanTerm;
import roqme.metamodel.expressions.AndEventTerm;
import roqme.metamodel.expressions.ArithFunction;
import roqme.metamodel.expressions.CollectionFunction;
import roqme.metamodel.expressions.ConditionalTerm;
import roqme.metamodel.expressions.ConstTerm;
import roqme.metamodel.expressions.ContextPattern;
import roqme.metamodel.expressions.DivTerm;
import roqme.metamodel.expressions.EqualTerm;
import roqme.metamodel.expressions.ExpressionsPackage;
import roqme.metamodel.expressions.FollowedByTerm;
import roqme.metamodel.expressions.GeneralExpression;
import roqme.metamodel.expressions.GreaterEqualTerm;
import roqme.metamodel.expressions.GreaterThanTerm;
import roqme.metamodel.expressions.LessEqualTerm;
import roqme.metamodel.expressions.LessThanTerm;
import roqme.metamodel.expressions.MultTerm;
import roqme.metamodel.expressions.NotBooleanTerm;
import roqme.metamodel.expressions.NotEqualTerm;
import roqme.metamodel.expressions.NotEventTerm;
import roqme.metamodel.expressions.OnceTerm;
import roqme.metamodel.expressions.OrBooleanTerm;
import roqme.metamodel.expressions.OrEventTerm;
import roqme.metamodel.expressions.OutputTransformation;
import roqme.metamodel.expressions.PatternFunction;
import roqme.metamodel.expressions.RangeTerm;
import roqme.metamodel.expressions.RepeatTerm;
import roqme.metamodel.expressions.ScheduleFunction;
import roqme.metamodel.expressions.SelfTerm;
import roqme.metamodel.expressions.SubTerm;
import roqme.metamodel.expressions.VarTerm;
import roqme.metamodel.expressions.WhileTerm;
import roqme.metamodel.kernel.BeliefVariable;
import roqme.metamodel.kernel.ClearEvidence;
import roqme.metamodel.kernel.DerivedContext;
import roqme.metamodel.kernel.GeneralPurposeVariable;
import roqme.metamodel.kernel.Observation;
import roqme.metamodel.kernel.PrimitiveContext;
import roqme.metamodel.kernel.Property;
import roqme.metamodel.kernel.ResumeTimer;
import roqme.metamodel.kernel.SetEvidence;
import roqme.metamodel.kernel.SetVariable;
import roqme.metamodel.kernel.StartTimer;
import roqme.metamodel.kernel.StopTimer;
import roqme.metamodel.kernel.Timer;

@SuppressWarnings("all")
public class MIRoNSemanticSequencer extends RoQMESemanticSequencer {

	@Inject
	private MIRoNGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DatatypesPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DatatypesPackage.ARRAY_VALUE:
				if (rule == grammarAccess.getBooleanArrayRule()) {
					sequence_BooleanArray(context, (ArrayValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypedValueRule()
						|| rule == grammarAccess.getArrayValueRule()) {
					sequence_BooleanArray_EnumArray_NumericArray_Impl_TimeArray(context, (ArrayValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEnumArrayRule()) {
					sequence_EnumArray(context, (ArrayValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNumericArray_ImplRule()) {
					sequence_NumericArray_Impl(context, (ArrayValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNumericArrayRule()) {
					sequence_NumericArray_Impl_TimeArray(context, (ArrayValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTimeArrayRule()) {
					sequence_TimeArray(context, (ArrayValue) semanticObject); 
					return; 
				}
				else break;
			case DatatypesPackage.BOOLEAN_TYPE:
				sequence_BooleanType(context, (BooleanType) semanticObject); 
				return; 
			case DatatypesPackage.BOOLEAN_VALUE:
				sequence_BooleanValue(context, (BooleanValue) semanticObject); 
				return; 
			case DatatypesPackage.CONTAINED_DECLARATION:
				sequence_ContainedDeclaration(context, (ContainedDeclaration) semanticObject); 
				return; 
			case DatatypesPackage.DATA_TYPE_DEFINITION:
				sequence_DataTypeDefinition(context, (DataTypeDefinition) semanticObject); 
				return; 
			case DatatypesPackage.ENUM_VALUE:
				sequence_EnumValue(context, (EnumValue) semanticObject); 
				return; 
			case DatatypesPackage.EVENT_TYPE:
				sequence_EventType(context, (EventType) semanticObject); 
				return; 
			case DatatypesPackage.EVENT_VALUE:
				sequence_EventValue(context, (EventValue) semanticObject); 
				return; 
			case DatatypesPackage.INBUILT_DECLARATION:
				sequence_InbuiltDeclaration(context, (InbuiltDeclaration) semanticObject); 
				return; 
			case DatatypesPackage.LOWER_BOUND:
				if (rule == grammarAccess.getCompactLowerBoundRule()) {
					sequence_CompactLowerBound(context, (LowerBound) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNumericTypeConstraintRule()
						|| rule == grammarAccess.getLowerBoundRule()) {
					sequence_LowerBound(context, (LowerBound) semanticObject); 
					return; 
				}
				else break;
			case DatatypesPackage.NUMERIC_TYPE:
				sequence_NumericType(context, (NumericType) semanticObject); 
				return; 
			case DatatypesPackage.NUMERIC_VALUE:
				sequence_NumericValue_Impl(context, (NumericValue) semanticObject); 
				return; 
			case DatatypesPackage.PRECISION:
				if (rule == grammarAccess.getCompactPrecisionRule()) {
					sequence_CompactPrecision(context, (Precision) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNumericTypeConstraintRule()
						|| rule == grammarAccess.getPrecisionRule()) {
					sequence_Precision(context, (Precision) semanticObject); 
					return; 
				}
				else break;
			case DatatypesPackage.REFERENCED_DECLARATION:
				sequence_ReferencedDeclaration(context, (ReferencedDeclaration) semanticObject); 
				return; 
			case DatatypesPackage.ROQME_MODEL:
				sequence_RoqmeModel(context, (RoqmeModel) semanticObject); 
				return; 
			case DatatypesPackage.SIMPLE_ENUM_LITERAL:
				sequence_SimpleEnumLiteral(context, (SimpleEnumLiteral) semanticObject); 
				return; 
			case DatatypesPackage.SIMPLE_ENUM_TYPE:
				sequence_SimpleEnumType(context, (SimpleEnumType) semanticObject); 
				return; 
			case DatatypesPackage.TIME_TYPE:
				sequence_TimeType(context, (TimeType) semanticObject); 
				return; 
			case DatatypesPackage.TIME_VALUE:
				sequence_TimeValue(context, (TimeValue) semanticObject); 
				return; 
			case DatatypesPackage.UPPER_BOUND:
				if (rule == grammarAccess.getCompactUpperBoundRule()) {
					sequence_CompactUpperBound(context, (UpperBound) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getNumericTypeConstraintRule()
						|| rule == grammarAccess.getUpperBoundRule()) {
					sequence_UpperBound(context, (UpperBound) semanticObject); 
					return; 
				}
				else break;
			}
		else if (epackage == miron.metamodel.datatypes.DatatypesPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case miron.metamodel.datatypes.DatatypesPackage.BEHAVIOR_TREE_ENUM_TYPE:
				sequence_BehaviorTreeEnumType(context, (BehaviorTreeEnumType) semanticObject); 
				return; 
			case miron.metamodel.datatypes.DatatypesPackage.BEHAVIOR_TREE_LITERAL:
				sequence_BehaviorTreeLiteral(context, (BehaviorTreeLiteral) semanticObject); 
				return; 
			case miron.metamodel.datatypes.DatatypesPackage.IMPACT_ON_QUALITY:
				sequence_ImpactOnQuality(context, (ImpactOnQuality) semanticObject); 
				return; 
			case miron.metamodel.datatypes.DatatypesPackage.MIRON_MODEL:
				sequence_MironModel(context, (MironModel) semanticObject); 
				return; 
			case miron.metamodel.datatypes.DatatypesPackage.NUMERIC_SAMPLED_TYPE:
				sequence_NumericSampledType(context, (NumericSampledType) semanticObject); 
				return; 
			case miron.metamodel.datatypes.DatatypesPackage.SAMPLE_VALUE:
				sequence_SampleValue(context, (SampleValue) semanticObject); 
				return; 
			}
		else if (epackage == ExpressionsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ExpressionsPackage.ADD_TERM:
				sequence_AdditionTerm(context, (AddTerm) semanticObject); 
				return; 
			case ExpressionsPackage.AGGREGATION_FUNCTION:
				sequence_AggregationFunction(context, (AggregationFunction) semanticObject); 
				return; 
			case ExpressionsPackage.AND_BOOLEAN_TERM:
				sequence_AndBooleanTerm(context, (AndBooleanTerm) semanticObject); 
				return; 
			case ExpressionsPackage.AND_EVENT_TERM:
				sequence_AndEventTerm(context, (AndEventTerm) semanticObject); 
				return; 
			case ExpressionsPackage.ARITH_FUNCTION:
				sequence_ArithFunction(context, (ArithFunction) semanticObject); 
				return; 
			case ExpressionsPackage.COLLECTION_FUNCTION:
				sequence_CollectionFunction(context, (CollectionFunction) semanticObject); 
				return; 
			case ExpressionsPackage.CONDITIONAL_TERM:
				sequence_ConditionalTerm(context, (ConditionalTerm) semanticObject); 
				return; 
			case ExpressionsPackage.CONST_TERM:
				sequence_ConstTerm(context, (ConstTerm) semanticObject); 
				return; 
			case ExpressionsPackage.CONTEXT_PATTERN:
				sequence_ContextPattern(context, (ContextPattern) semanticObject); 
				return; 
			case ExpressionsPackage.DIV_TERM:
				sequence_MultiplicationTerm(context, (DivTerm) semanticObject); 
				return; 
			case ExpressionsPackage.EQUAL_TERM:
				sequence_RelationalTerm(context, (EqualTerm) semanticObject); 
				return; 
			case ExpressionsPackage.FOLLOWED_BY_TERM:
				sequence_SequenceTerm(context, (FollowedByTerm) semanticObject); 
				return; 
			case ExpressionsPackage.GENERAL_EXPRESSION:
				sequence_GeneralExpression(context, (GeneralExpression) semanticObject); 
				return; 
			case ExpressionsPackage.GREATER_EQUAL_TERM:
				sequence_RelationalTerm(context, (GreaterEqualTerm) semanticObject); 
				return; 
			case ExpressionsPackage.GREATER_THAN_TERM:
				sequence_RelationalTerm(context, (GreaterThanTerm) semanticObject); 
				return; 
			case ExpressionsPackage.LESS_EQUAL_TERM:
				sequence_RelationalTerm(context, (LessEqualTerm) semanticObject); 
				return; 
			case ExpressionsPackage.LESS_THAN_TERM:
				sequence_RelationalTerm(context, (LessThanTerm) semanticObject); 
				return; 
			case ExpressionsPackage.MULT_TERM:
				sequence_MultiplicationTerm(context, (MultTerm) semanticObject); 
				return; 
			case ExpressionsPackage.NOT_BOOLEAN_TERM:
				sequence_NotBooleanTerm(context, (NotBooleanTerm) semanticObject); 
				return; 
			case ExpressionsPackage.NOT_EQUAL_TERM:
				sequence_RelationalTerm(context, (NotEqualTerm) semanticObject); 
				return; 
			case ExpressionsPackage.NOT_EVENT_TERM:
				sequence_NotEventTerm(context, (NotEventTerm) semanticObject); 
				return; 
			case ExpressionsPackage.ONCE_TERM:
				sequence_OnceTerm(context, (OnceTerm) semanticObject); 
				return; 
			case ExpressionsPackage.OR_BOOLEAN_TERM:
				sequence_OrBooleanTerm(context, (OrBooleanTerm) semanticObject); 
				return; 
			case ExpressionsPackage.OR_EVENT_TERM:
				sequence_OrEventTerm(context, (OrEventTerm) semanticObject); 
				return; 
			case ExpressionsPackage.OUTPUT_TRANSFORMATION:
				sequence_OutputTransformation(context, (OutputTransformation) semanticObject); 
				return; 
			case ExpressionsPackage.PATTERN_FUNCTION:
				sequence_PatternFunction(context, (PatternFunction) semanticObject); 
				return; 
			case ExpressionsPackage.RANGE_TERM:
				sequence_RepetionTerm(context, (RangeTerm) semanticObject); 
				return; 
			case ExpressionsPackage.REPEAT_TERM:
				sequence_RepetionTerm(context, (RepeatTerm) semanticObject); 
				return; 
			case ExpressionsPackage.SCHEDULE_FUNCTION:
				sequence_ScheduleFunction(context, (ScheduleFunction) semanticObject); 
				return; 
			case ExpressionsPackage.SELF_TERM:
				sequence_SelfTerm(context, (SelfTerm) semanticObject); 
				return; 
			case ExpressionsPackage.SUB_TERM:
				sequence_AdditionTerm(context, (SubTerm) semanticObject); 
				return; 
			case ExpressionsPackage.VAR_TERM:
				sequence_VarTerm(context, (VarTerm) semanticObject); 
				return; 
			case ExpressionsPackage.WHILE_TERM:
				sequence_WhileTerm(context, (WhileTerm) semanticObject); 
				return; 
			}
		else if (epackage == KernelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case KernelPackage.ARCH_BINDING:
				sequence_ArchBinding(context, (ArchBinding) semanticObject); 
				return; 
			case KernelPackage.BT_BINDING:
				sequence_BtBinding(context, (BtBinding) semanticObject); 
				return; 
			case KernelPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case KernelPackage.CONSTRAINT:
				sequence_Constraint(context, (Constraint) semanticObject); 
				return; 
			case KernelPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case KernelPackage.RULE:
				sequence_Rule(context, (Rule) semanticObject); 
				return; 
			case KernelPackage.VARIATION_POINT:
				sequence_VariationPoint(context, (VariationPoint) semanticObject); 
				return; 
			}
		else if (epackage == roqme.metamodel.kernel.KernelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case roqme.metamodel.kernel.KernelPackage.BELIEF_VARIABLE:
				sequence_BeliefVariableImpl(context, (BeliefVariable) semanticObject); 
				return; 
			case roqme.metamodel.kernel.KernelPackage.CLEAR_EVIDENCE:
				sequence_ClearEvidence(context, (ClearEvidence) semanticObject); 
				return; 
			case roqme.metamodel.kernel.KernelPackage.DERIVED_CONTEXT:
				sequence_DerivedContext(context, (DerivedContext) semanticObject); 
				return; 
			case roqme.metamodel.kernel.KernelPackage.GENERAL_PURPOSE_VARIABLE:
				sequence_GeneralPurposeVariable(context, (GeneralPurposeVariable) semanticObject); 
				return; 
			case roqme.metamodel.kernel.KernelPackage.OBSERVATION:
				sequence_Observation(context, (Observation) semanticObject); 
				return; 
			case roqme.metamodel.kernel.KernelPackage.PARAMETER:
				sequence_Parameter(context, (roqme.metamodel.kernel.Parameter) semanticObject); 
				return; 
			case roqme.metamodel.kernel.KernelPackage.PRIMITIVE_CONTEXT:
				sequence_PrimitiveContext(context, (PrimitiveContext) semanticObject); 
				return; 
			case roqme.metamodel.kernel.KernelPackage.PROPERTY:
				sequence_Property(context, (Property) semanticObject); 
				return; 
			case roqme.metamodel.kernel.KernelPackage.RESUME_TIMER:
				sequence_ResumeTimer(context, (ResumeTimer) semanticObject); 
				return; 
			case roqme.metamodel.kernel.KernelPackage.SET_EVIDENCE:
				sequence_SetEvidence(context, (SetEvidence) semanticObject); 
				return; 
			case roqme.metamodel.kernel.KernelPackage.SET_VARIABLE:
				sequence_SetVariable(context, (SetVariable) semanticObject); 
				return; 
			case roqme.metamodel.kernel.KernelPackage.START_TIMER:
				sequence_StartTimer(context, (StartTimer) semanticObject); 
				return; 
			case roqme.metamodel.kernel.KernelPackage.STOP_TIMER:
				sequence_StopTimer(context, (StopTimer) semanticObject); 
				return; 
			case roqme.metamodel.kernel.KernelPackage.TIMER:
				sequence_Timer(context, (Timer) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Binding returns ArchBinding
	 *     ArchBinding returns ArchBinding
	 *
	 * Constraint:
	 *     (parameterSetRepository=EString | parameterSet=EString | component=EString | parameter=EString)+
	 */
	protected void sequence_ArchBinding(ISerializationContext context, ArchBinding semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns BehaviorTreeEnumType
	 *     EnumType returns BehaviorTreeEnumType
	 *     BehaviorTreeEnumType returns BehaviorTreeEnumType
	 *
	 * Constraint:
	 *     (cardinality=INT? literals+=BehaviorTreeLiteral literals+=BehaviorTreeLiteral*)
	 */
	protected void sequence_BehaviorTreeEnumType(ISerializationContext context, BehaviorTreeEnumType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BehaviorTreeLiteral returns BehaviorTreeLiteral
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (preset?='preset' | reference=[BehaviorTree|QualifiedName]) 
	 *         (impacts+=ImpactOnQuality | (impacts+=ImpactOnQuality impacts+=ImpactOnQuality*))?
	 *     )
	 */
	protected void sequence_BehaviorTreeLiteral(ISerializationContext context, BehaviorTreeLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Binding returns BtBinding
	 *     BtBinding returns BtBinding
	 *
	 * Constraint:
	 *     (insertionType=InsertionTypeEnum xpath=EString? targets+=[EObject|QualifiedName] targets+=[EObject|QualifiedName]*)
	 */
	protected void sequence_BtBinding(ISerializationContext context, BtBinding semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     term=Term
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KernelPackage.Literals.CONDITION__TERM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KernelPackage.Literals.CONDITION__TERM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionAccess().getTermTermParserRuleCall_0(), semanticObject.getTerm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns Constraint
	 *
	 * Constraint:
	 *     term=Term
	 */
	protected void sequence_Constraint(ISerializationContext context, Constraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KernelPackage.Literals.CONSTRAINT__TERM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KernelPackage.Literals.CONSTRAINT__TERM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstraintAccess().getTermTermParserRuleCall_0(), semanticObject.getTerm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ImpactOnQuality returns ImpactOnQuality
	 *
	 * Constraint:
	 *     (property=[Property|QualifiedName] intensity=ImpactIntensityEnum)
	 */
	protected void sequence_ImpactOnQuality(ISerializationContext context, ImpactOnQuality semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, miron.metamodel.datatypes.DatatypesPackage.Literals.IMPACT_ON_QUALITY__PROPERTY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, miron.metamodel.datatypes.DatatypesPackage.Literals.IMPACT_ON_QUALITY__PROPERTY));
			if (transientValues.isValueTransient(semanticObject, miron.metamodel.datatypes.DatatypesPackage.Literals.IMPACT_ON_QUALITY__INTENSITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, miron.metamodel.datatypes.DatatypesPackage.Literals.IMPACT_ON_QUALITY__INTENSITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImpactOnQualityAccess().getPropertyPropertyQualifiedNameParserRuleCall_0_0_1(), semanticObject.eGet(miron.metamodel.datatypes.DatatypesPackage.Literals.IMPACT_ON_QUALITY__PROPERTY, false));
		feeder.accept(grammarAccess.getImpactOnQualityAccess().getIntensityImpactIntensityEnumEnumRuleCall_1_0(), semanticObject.getIntensity());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     (importURI=EString alias=EString?)
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MironModel returns MironModel
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             ((description=ElementDescription? namespace=EString sentences+=Import+) | sentences+=Import+)? 
	 *             (dataTypes+=DataTypeDefinition | variables+=TypedVariable | sentences+=Sentence)+
	 *         ) | 
	 *         (dataTypes+=DataTypeDefinition | variables+=TypedVariable | sentences+=Sentence)+
	 *     )?
	 */
	protected void sequence_MironModel(ISerializationContext context, MironModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataType returns NumericSampledType
	 *     NumericSampledType returns NumericSampledType
	 *
	 * Constraint:
	 *     (
	 *         cardinality=INT? 
	 *         (
	 *             (measurementUnit=EString | constraints+=NumericTypeConstraint)? 
	 *             (constraints+=CompactLowerBound constraints+=CompactUpperBound)? 
	 *             (constraints+=CompactLowerBound constraints+=CompactPrecision constraints+=CompactUpperBound)?
	 *         )+ 
	 *         samples+=SampleValue 
	 *         samples+=SampleValue*
	 *     )
	 */
	protected void sequence_NumericSampledType(ISerializationContext context, NumericSampledType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Sentence returns Rule
	 *     Rule returns Rule
	 *
	 * Constraint:
	 *     (name=ID condition=Condition? (implies+=Constraint | (implies+=Constraint implies+=Constraint+)))
	 */
	protected void sequence_Rule(ISerializationContext context, Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SampleValue returns SampleValue
	 *
	 * Constraint:
	 *     (value=NumericValue (impacts+=ImpactOnQuality | (impacts+=ImpactOnQuality impacts+=ImpactOnQuality*))?)
	 */
	protected void sequence_SampleValue(ISerializationContext context, SampleValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypedVariable returns VariationPoint
	 *     VariationPoint returns VariationPoint
	 *
	 * Constraint:
	 *     (name=ID declaration=DataTypeDeclaration binding=Binding?)
	 */
	protected void sequence_VariationPoint(ISerializationContext context, VariationPoint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
