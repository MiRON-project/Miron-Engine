/*
 * generated by Xtext 2.12.0
 */
package org.xtext.behaviortree.serializer;

import behaviortree.AlwaysFailure;
import behaviortree.AlwaysSuccess;
import behaviortree.Attribute;
import behaviortree.BTModel;
import behaviortree.BehaviorTree;
import behaviortree.BehaviorTreePackage;
import behaviortree.BlackboardCheckDouble;
import behaviortree.BlackboardCheckInt;
import behaviortree.BlackboardCheckString;
import behaviortree.Condition;
import behaviortree.Fallback;
import behaviortree.FallbackStar;
import behaviortree.ForceFailure;
import behaviortree.ForceSuccess;
import behaviortree.Import;
import behaviortree.Inverter;
import behaviortree.Parallel;
import behaviortree.Repeat;
import behaviortree.RetryUntilSuccess;
import behaviortree.Sequence;
import behaviortree.SequenceStar;
import behaviortree.SetBlackboard;
import behaviortree.Subtree;
import behaviortree.SubtreePlus;
import behaviortree.Switch;
import behaviortree.Timeout;
import behaviortree.TreeNodesModel;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.behaviortree.services.BehaviorTreeGrammarAccess;

@SuppressWarnings("all")
public abstract class AbstractBehaviorTreeSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private BehaviorTreeGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == BehaviorTreePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case BehaviorTreePackage.ACTION:
				sequence_Action(context, (behaviortree.Action) semanticObject); 
				return; 
			case BehaviorTreePackage.ALWAYS_FAILURE:
				sequence_AlwaysFailure(context, (AlwaysFailure) semanticObject); 
				return; 
			case BehaviorTreePackage.ALWAYS_SUCCESS:
				sequence_AlwaysSuccess(context, (AlwaysSuccess) semanticObject); 
				return; 
			case BehaviorTreePackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case BehaviorTreePackage.BT_MODEL:
				sequence_BTModel(context, (BTModel) semanticObject); 
				return; 
			case BehaviorTreePackage.BEHAVIOR_TREE:
				sequence_BehaviorTree(context, (BehaviorTree) semanticObject); 
				return; 
			case BehaviorTreePackage.BLACKBOARD_CHECK_DOUBLE:
				sequence_BlackboardCheckDouble(context, (BlackboardCheckDouble) semanticObject); 
				return; 
			case BehaviorTreePackage.BLACKBOARD_CHECK_INT:
				sequence_BlackboardCheckInt(context, (BlackboardCheckInt) semanticObject); 
				return; 
			case BehaviorTreePackage.BLACKBOARD_CHECK_STRING:
				sequence_BlackboardCheckString(context, (BlackboardCheckString) semanticObject); 
				return; 
			case BehaviorTreePackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case BehaviorTreePackage.FALLBACK:
				sequence_Fallback(context, (Fallback) semanticObject); 
				return; 
			case BehaviorTreePackage.FALLBACK_STAR:
				sequence_FallbackStar(context, (FallbackStar) semanticObject); 
				return; 
			case BehaviorTreePackage.FORCE_FAILURE:
				sequence_ForceFailure(context, (ForceFailure) semanticObject); 
				return; 
			case BehaviorTreePackage.FORCE_SUCCESS:
				sequence_ForceSuccess(context, (ForceSuccess) semanticObject); 
				return; 
			case BehaviorTreePackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case BehaviorTreePackage.INVERTER:
				sequence_Inverter(context, (Inverter) semanticObject); 
				return; 
			case BehaviorTreePackage.PARALLEL:
				sequence_Parallel(context, (Parallel) semanticObject); 
				return; 
			case BehaviorTreePackage.REPEAT:
				sequence_Repeat(context, (Repeat) semanticObject); 
				return; 
			case BehaviorTreePackage.RETRY_UNTIL_SUCCESS:
				sequence_RetryUntilSuccess(context, (RetryUntilSuccess) semanticObject); 
				return; 
			case BehaviorTreePackage.SEQUENCE:
				sequence_Sequence(context, (Sequence) semanticObject); 
				return; 
			case BehaviorTreePackage.SEQUENCE_STAR:
				sequence_SequenceStar(context, (SequenceStar) semanticObject); 
				return; 
			case BehaviorTreePackage.SET_BLACKBOARD:
				sequence_SetBlackboard(context, (SetBlackboard) semanticObject); 
				return; 
			case BehaviorTreePackage.SUBTREE:
				sequence_Subtree(context, (Subtree) semanticObject); 
				return; 
			case BehaviorTreePackage.SUBTREE_PLUS:
				sequence_SubtreePlus(context, (SubtreePlus) semanticObject); 
				return; 
			case BehaviorTreePackage.SWITCH:
				sequence_Switch(context, (Switch) semanticObject); 
				return; 
			case BehaviorTreePackage.TIMEOUT:
				sequence_Timeout(context, (Timeout) semanticObject); 
				return; 
			case BehaviorTreePackage.TREE_NODES_MODEL:
				sequence_TreeNodesModel(context, (TreeNodesModel) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     TreeNode returns Action
	 *     LeafNode returns Action
	 *     AbstractAction returns Action
	 *     Action returns Action
	 *
	 * Constraint:
	 *     attributes+=Attribute*
	 */
	protected void sequence_Action(ISerializationContext context, behaviortree.Action semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TreeNode returns AlwaysFailure
	 *     LeafNode returns AlwaysFailure
	 *     AbstractAction returns AlwaysFailure
	 *     AlwaysFailure returns AlwaysFailure
	 *
	 * Constraint:
	 *     attributes+=Attribute*
	 */
	protected void sequence_AlwaysFailure(ISerializationContext context, AlwaysFailure semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TreeNode returns AlwaysSuccess
	 *     LeafNode returns AlwaysSuccess
	 *     AbstractAction returns AlwaysSuccess
	 *     AlwaysSuccess returns AlwaysSuccess
	 *
	 * Constraint:
	 *     attributes+=Attribute*
	 */
	protected void sequence_AlwaysSuccess(ISerializationContext context, AlwaysSuccess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (name=ID value=STRING)
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorTreePackage.Literals.ATTRIBUTE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorTreePackage.Literals.ATTRIBUTE__NAME));
			if (transientValues.isValueTransient(semanticObject, BehaviorTreePackage.Literals.ATTRIBUTE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorTreePackage.Literals.ATTRIBUTE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAttributeAccess().getValueSTRINGTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BTModel returns BTModel
	 *
	 * Constraint:
	 *     (main_tree_to_execute=[BehaviorTree|STRING] imports+=Import* (trees+=BehaviorTree | nodesmodel=TreeNodesModel)*)
	 */
	protected void sequence_BTModel(ISerializationContext context, BTModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BehaviorTree returns BehaviorTree
	 *
	 * Constraint:
	 *     (attributes+=Attribute* nodes+=TreeNode+)
	 */
	protected void sequence_BehaviorTree(ISerializationContext context, BehaviorTree semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TreeNode returns BlackboardCheckDouble
	 *     DecoratorNode returns BlackboardCheckDouble
	 *     BlackboardCheckDouble returns BlackboardCheckDouble
	 *
	 * Constraint:
	 *     (attributes+=Attribute* node=TreeNode)
	 */
	protected void sequence_BlackboardCheckDouble(ISerializationContext context, BlackboardCheckDouble semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TreeNode returns BlackboardCheckInt
	 *     DecoratorNode returns BlackboardCheckInt
	 *     BlackboardCheckInt returns BlackboardCheckInt
	 *
	 * Constraint:
	 *     (attributes+=Attribute* node=TreeNode)
	 */
	protected void sequence_BlackboardCheckInt(ISerializationContext context, BlackboardCheckInt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TreeNode returns BlackboardCheckString
	 *     DecoratorNode returns BlackboardCheckString
	 *     BlackboardCheckString returns BlackboardCheckString
	 *
	 * Constraint:
	 *     (attributes+=Attribute* node=TreeNode)
	 */
	protected void sequence_BlackboardCheckString(ISerializationContext context, BlackboardCheckString semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TreeNode returns Condition
	 *     LeafNode returns Condition
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     attributes+=Attribute*
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TreeNode returns FallbackStar
	 *     ControlNode returns FallbackStar
	 *     FallbackStar returns FallbackStar
	 *
	 * Constraint:
	 *     (attributes+=Attribute* nodes+=TreeNode+)
	 */
	protected void sequence_FallbackStar(ISerializationContext context, FallbackStar semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TreeNode returns Fallback
	 *     ControlNode returns Fallback
	 *     Fallback returns Fallback
	 *
	 * Constraint:
	 *     (attributes+=Attribute* nodes+=TreeNode+)
	 */
	protected void sequence_Fallback(ISerializationContext context, Fallback semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TreeNode returns ForceFailure
	 *     DecoratorNode returns ForceFailure
	 *     ForceFailure returns ForceFailure
	 *
	 * Constraint:
	 *     (attributes+=Attribute* node=TreeNode)
	 */
	protected void sequence_ForceFailure(ISerializationContext context, ForceFailure semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TreeNode returns ForceSuccess
	 *     DecoratorNode returns ForceSuccess
	 *     ForceSuccess returns ForceSuccess
	 *
	 * Constraint:
	 *     (attributes+=Attribute* node=TreeNode)
	 */
	protected void sequence_ForceSuccess(ISerializationContext context, ForceSuccess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importURI=STRING
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorTreePackage.Literals.IMPORT__IMPORT_URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorTreePackage.Literals.IMPORT__IMPORT_URI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportURISTRINGTerminalRuleCall_4_0(), semanticObject.getImportURI());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TreeNode returns Inverter
	 *     DecoratorNode returns Inverter
	 *     Inverter returns Inverter
	 *
	 * Constraint:
	 *     (attributes+=Attribute* node=TreeNode)
	 */
	protected void sequence_Inverter(ISerializationContext context, Inverter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TreeNode returns Parallel
	 *     ControlNode returns Parallel
	 *     Parallel returns Parallel
	 *
	 * Constraint:
	 *     (attributes+=Attribute* nodes+=TreeNode+)
	 */
	protected void sequence_Parallel(ISerializationContext context, Parallel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TreeNode returns Repeat
	 *     DecoratorNode returns Repeat
	 *     Repeat returns Repeat
	 *
	 * Constraint:
	 *     (attributes+=Attribute* node=TreeNode)
	 */
	protected void sequence_Repeat(ISerializationContext context, Repeat semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TreeNode returns RetryUntilSuccess
	 *     DecoratorNode returns RetryUntilSuccess
	 *     RetryUntilSuccess returns RetryUntilSuccess
	 *
	 * Constraint:
	 *     (attributes+=Attribute* node=TreeNode)
	 */
	protected void sequence_RetryUntilSuccess(ISerializationContext context, RetryUntilSuccess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TreeNode returns SequenceStar
	 *     ControlNode returns SequenceStar
	 *     SequenceStar returns SequenceStar
	 *
	 * Constraint:
	 *     (attributes+=Attribute* nodes+=TreeNode+)
	 */
	protected void sequence_SequenceStar(ISerializationContext context, SequenceStar semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TreeNode returns Sequence
	 *     ControlNode returns Sequence
	 *     Sequence returns Sequence
	 *
	 * Constraint:
	 *     (attributes+=Attribute* nodes+=TreeNode+)
	 */
	protected void sequence_Sequence(ISerializationContext context, Sequence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TreeNode returns SetBlackboard
	 *     LeafNode returns SetBlackboard
	 *     AbstractAction returns SetBlackboard
	 *     SetBlackboard returns SetBlackboard
	 *
	 * Constraint:
	 *     attributes+=Attribute*
	 */
	protected void sequence_SetBlackboard(ISerializationContext context, SetBlackboard semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TreeNode returns SubtreePlus
	 *     SubtreeNode returns SubtreePlus
	 *     SubtreePlus returns SubtreePlus
	 *
	 * Constraint:
	 *     (behaviortree=[BehaviorTree|STRING] attributes+=Attribute*)
	 */
	protected void sequence_SubtreePlus(ISerializationContext context, SubtreePlus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TreeNode returns Subtree
	 *     SubtreeNode returns Subtree
	 *     Subtree returns Subtree
	 *
	 * Constraint:
	 *     (behaviortree=[BehaviorTree|STRING] attributes+=Attribute*)
	 */
	protected void sequence_Subtree(ISerializationContext context, Subtree semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TreeNode returns Switch
	 *     ControlNode returns Switch
	 *     Switch returns Switch
	 *
	 * Constraint:
	 *     (attributes+=Attribute* nodes+=TreeNode*)
	 */
	protected void sequence_Switch(ISerializationContext context, Switch semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TreeNode returns Timeout
	 *     DecoratorNode returns Timeout
	 *     Timeout returns Timeout
	 *
	 * Constraint:
	 *     (attributes+=Attribute* node=TreeNode)
	 */
	protected void sequence_Timeout(ISerializationContext context, Timeout semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TreeNodesModel returns TreeNodesModel
	 *
	 * Constraint:
	 *     content=EString
	 */
	protected void sequence_TreeNodesModel(ISerializationContext context, TreeNodesModel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BehaviorTreePackage.Literals.TREE_NODES_MODEL__CONTENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BehaviorTreePackage.Literals.TREE_NODES_MODEL__CONTENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTreeNodesModelAccess().getContentEStringParserRuleCall_1_0(), semanticObject.getContent());
		feeder.finish();
	}
	
	
}
